#puts 'hello world'

# if ARGV.count < 1
#     puts "Артём" 
# end
  
# user = ARGV[0]
# puts "hello #{user}"
# puts "Какой твой любимый язык програмирования?"
# lang = STDIN.gets.chomp.downcase #руби вызовет этот метод у объекта стандартного ввода и будет точно
#                                     # читать именно из консоли, не отвлекаясь на ARGV.

# case lang
# when "ruby"
#     puts "кринж"
# when "#"
#     puts "уверено"
# when "python"
#     puts "Рома"
# when "dart"
#     puts "Серега"
# else puts "больше языков нет"
# end

# require 'open3'

# puts "Введите команду для выполнения её OC:"
# cmd = gets.chomp()
# system(cmd)

# puts "Теперь введите код на Ruby:"
# rubyCmd = gets.chomp()
# system " ruby -e \'#{rubyCmd}\'"

#Метод 1 Найти количество чисел, взаимно простых с заданным.
#Метод 2 Найти сумму цифр числа, делящихся на 3
#Метод 3 Найти делитель числа, являющийся взаимно простым с
#наибольшим количеством цифр данного числа.

# def nod(a, b) 
#     if (b == 0) then a
#     else nod(b, a % b)
#     end
# end

# def simple(a, b) 
#     1 == nod(a, b)
# end

# def euler(n, m = n, acc = 1) #функция Эйлера
#     if m == 1 then acc
#     else euler(n, m-1, (simple(n, m) ? 1:0 ) + acc)
#     end
# end

# puts(euler(10))

# def sum(num)
#     rez= 0
#     num.digits.each { 
#         |dig| 
#         if dig % 3 == 0
#             res += dig 
#         end
#     }
#     return rez
# end

# def otv(n)
#     divisors = (2...n).select{|numbers| n%numbers == 0}
#     count=0
#     array=[]
#     for i in divisors do
#         n.digits.each { 
#                     |dig| 
#                     if simple(i,dig)
#                         count+=1
#                     end
#                 }
#         array<<count       
#     end
#     return array.max
# end

# puts(otv(123))

def minArr(arr)
    min = arr.min
    return min
end

# def firstPos(arr)
#     for i in 0..arr.length
#         return i if arr[i].to_i > 0
#     end
#     return -1
# end

# if ARGV.count < 2
#     puts "Аргументы отсутствуют"
#     return
# end

# method = ARGV[0]
# path = ARGV[1]

# file = File.open(path)
# array = file.readline.split(' ').map(&:to_i)

# puts "Массив, #{array}\n"
# case method
# when "1"
#     puts "Минимальный элемент: #{minArr(array)}"
# when "2"
#     puts "Номер первого положительного элемента: #{firstPos(array)}"
# else 
#     puts "Метода под номером #{method} не существует"
# end

#1.8 дан целочисленный массив. Необходимо найти индексы двух наименьших элементов массива.

# def indexMin(arr)
#     #val1= minArr(arr)
#     indx1=arr.index(minArr(arr))
#     arr.fill(indx1,indx1) {|index| 10000}
#     #arr.delete(indx1)
#     #val2= minArr(arr)
#     indx2=arr.index(minArr(arr))
#     return indx1,indx2
# end

# puts(indexMin([1,2,3,-3,-5]))

#1.20 Дан целочисленный массив. Необходимо найти все пропущенные числа.
def findmiss(arr)
    (arr.min..arr.max).to_a - arr
end
puts(findmiss([1,2,5,6,9]))